# ì‹œìŠ¤í…œ í”„ë¡œê·¸ë¨ 2ì£¼ ì°¨

ë¬¸ì, ì •ìˆ˜, ì‹¤ìˆ˜ë¥¼ í‘œí˜„í•˜ê³  ì¡°ì‘í•˜ëŠ” ë°©ë²•ì„ ë°°ìš°ê²Œ ëœë‹¤.

## Information Storage

ì´ë¯¸ ë‹¤ë¥¸ ê°•ì˜ì—ì„œ ìˆ˜ì—…í•´ì„œ Byte, Wordì— ëŒ€í•œ ê¸°ì´ˆ ì„¤ëª…ì€ íŒ¨ìŠ¤!

|type|32-bit M| 64-bit M|
|-|-|-|
|char|1|1|
|short|2|2|
|int|4|4|
|ğŸ˜€ long|4|8|
|int32_t|4|4|
|int64_t|8|8|
|ğŸ˜€ char *|4|8|
|float|4|4|
|double|8|8|

32bit, 64bit ì‹œìŠ¤í…œì€ ì„œë¡œ C ì–¸ì–´ì˜ ë°ì´í„° íƒ€ì…(long, char*)ë§ˆë‹¤ì˜ ìš©ëŸ‰ì´ ë‹¤ë¥¼ ìˆ˜ ìˆë‹¤.

### Byte ordering

ë©”ëª¨ë¦¬ì— ê°ì²´ë¥¼ ì–´ë–»ê²Œ ì €ì¥í• ì§€ ì •í•˜ëŠ” ê²ƒì´ë‹¤.

- Little edian
  - LSB to MSB
  - e.g. 0x01234567 -> 01, 23, 45, 67
- Big endian
  - MSB to LSB
  - e.g. 0x01234567 -> 67, 45, 23, 01
  - ì£¼ë¡œ ì‚¬ìš©í•˜ëŠ” ì¸í…” ì‹œìŠ¤í…œì—ì„œ Byte ordering

### Strings

ë¬¸ìì—´ ë§ˆì§€ë§‰ì€ NULL(Ox00)ì´ê³  ASCII ì½”ë“œë¥¼ ì‚¬ìš©í•´ì„œ í‘œí˜„í•œë‹¤. (ìˆ«ìë„ ASCIIì— ë”°ë¼ í‘œí˜„í•œë‹¤.)

### Code

ê°™ì€ ì½”ë“œì´ë”ë¼ë„ OSë‚˜ ì‹œìŠ¤í…œì´ ë‹¤ë¥´ë©´ ë‹¤ë¥´ê²Œ ë‚˜íƒ€ë‚¸ë‹¤. ì•ìœ¼ë¡œëŠ” ì¸í…” 64bit ê¸°ì¤€ìœ¼ë¡œ ë°°ìš¸ ì˜ˆì •ì´ë‹¤.

### Bit-level operations in C

- ~
  - NOT ì—°ì‚°ì
- &
  - AND ì—°ì‚°ì
  - maskingì„ ìœ„í•´ì„œ ë§ì´ ì‚¬ìš©í•œë‹¤.
    - e.g. 0x1234ABCD & 0xFF = 0xCD
- |
  - OR ì—°ì‚°ì
- ^
  - XOR ì—°ì‚°ì

### Logical operations in C

&&ëŠ” ë‘˜ ì¤‘ì˜ í•˜ë‚˜ê°€ 0ì´ë©´ 0ì´ë¯€ë¡œ ì•ì— ê°€ ì´ë¯¸ 0ì´ë©´ ë’¤ì—ëŠ” ê³„ì‚°í•  í•„ìš”ê°€ ì—†ì–´ì„œ í•˜ì§€ ì•Šìœ¼ë‹ˆ ì´ë¥¼ ì¡°ì‹¬í•´ì•¼ í•œë‹¤.

> ì´ë¥¼ Early Evaluationì´ë¼ê³  í•œë‹¤.

### Shift operations in C

- x << k
  - xë¥¼ k bitsë§Œí¼ ì™¼ìª½ìœ¼ë¡œ ì›€ì§ì´ëŠ”ë° ë„˜ì–´ê°€ë©´ ì‚¬ë¼ì§€ê³  ë¹„ì–´ ìˆëŠ” ê³µê°„ì€ 0ìœ¼ë¡œ ì±„ì›Œì§€ê²Œ ëœë‹¤.
- x >> k
  - ìœ„ ì—°ì‚°ìì˜ ë°˜ëŒ€ì´ì§€ë§Œ ë¹„ì–´ ìˆëŠ” ê³µê°„ì„ signed ê°™ì€ ê²½ìš° ë§¨ ì™¼ìª½ì— ìˆë˜ ê°’ìœ¼ë¡œ(arithmetic right shift) ê·¸ë¦¬ê³  unsigned ê°™ì€ ê²½ìš°ì—ëŠ” 0ìœ¼ë¡œ(logical right shift) ì±„ì›Œì§€ê²Œ ëœë‹¤.

## Integer Representations

Cì˜ ê²½ìš° limits.h íŒŒì¼ì„ í†µí•´ ê° ë°ì´í„°ì˜ ìµœì†Œ ìµœëŒ“ê°’ì„ ì•Œ ìˆ˜ê°€ ìˆë‹¤.

### Encoding unsigned integers

B2U(X)ëŠ” 2^i * X[i]ë¥¼ ëª¨ë‘ ë”í•œ ê²ƒê³¼ ê°™ë‹¤. ë²”ìœ„ëŠ” [0, 2^w - 1]ê³¼ ê°™ë‹¤.

### Encoding signed integers

- Signed-magnitude (B2S)
  - MSBë¥¼ Sign bitë¡œ ì‚¬ìš©í•´ì„œ ì–‘ìˆ˜, ìŒìˆ˜ë¥¼ êµ¬ë¶„
  - 0ì˜ í‘œí˜„ì´ 2ê°œì´ë‹¤.
  - floating-point numbersì—ì„œ ì¼ë¶€ ì‚¬ìš©ëœë‹¤.
- 1's-complement (B2O)
  - MSBë¥¼ Sign bitë¡œ ì‚¬ìš©
  - 1001 -> 0110, -6 -> 6 ë°©ì‹ìœ¼ë¡œ ë³€í™˜
  - 0ì˜ í‘œí˜„ì´ 2ê°œì´ë‹¤.
- 2' s-complement (B2T)
  - 0ì˜ í‘œí˜„ì€ í•˜ë‚˜ì´ë‹¤. ë”°ë¼ì„œ ìŒìˆ˜ í•˜ë‚˜ë¥¼ ë” í‘œí˜„í•  ìˆ˜ ìˆë‹¤.
  - ~x +1 == -x
  - í‘œí˜„ ë²”ìœ„ëŠ” [-2^(w-1), 2^(w-1)-1]ì´ë‹¤.

### Type conversion (signed <-> unsigned)

#### unsigned -> signed

||Decimal|Binary|
|-|-|-|
|unsigned short x|2003|00000111 11010011|
|short ix = (short) x|2003|00000111 11010011|
|unsigend short y|47806|10111010 10111110|
|short iy = (short) y|-17730|10111010 10111110|

- x < 2^(w-1)ì¼ ë• -> x
- x >= 2^(w-1)ì¼ ë• -> x - 2^w

bit patternì€ ìœ ì§€ë˜ëŠ”ë° signed numberë¡œ í•´ì„ëœë‹¤. í‘œí˜„í•  ìˆ˜ ìˆëŠ” ê³µí†µëœ ë¶€ë¶„ì€ ê·¸ëŒ€ë¡œ ìœ ì§€ë˜ì§€ë§Œ, ë‚˜ë¨¸ì§€ëŠ” ìŒìˆ˜ ìª½ìœ¼ë¡œ ë‚´ë ¤ê°€ê²Œ ëœë‹¤.

#### signed -> unsigned

||Decimal|Binary|
|-|-|-|
|short ix|2003|00000111 11010011|
|unsigned short x = (unsigend short) ix|2003|00000111 11010011|
|short iy|-2003|10111010 10111110|
|unsigend short y = (unsigend short) iy|63533|10111010 10111110|

- x >= 0ì¼ ë• -> x
- x < 0ì¼ ë• -> x + 2^w

bit patternì€ ìœ ì§€ë˜ëŠ”ë° unsigned numberë¡œ í•´ì„ëœë‹¤. ìœ„ì™€ ë‹¬ë¦¬ ìŒ ìˆ˜ë¶€ë¶„ì´ ê³µí†µë¶€ë¶„ ìœ„ë¡œ ì˜¬ë¼ê°€ê²Œ ëœë‹¤.

#### Type conversion in C

Cì—ì„œëŠ” ì´ëŸ¬í•œ ê³¼ì •ë“¤ì´ Explicit(ëª…ì‹œì ), Implicit(ì•”ì‹œì ) ë‘ ë°©ì‹ ëª¨ë‘ ì‘ë™í•˜ê²Œ ëœë‹¤.

> e.g. (int) ux, tx = ux ê°ê° explicitì™€ implicitì´ë‹¤.

|Expression|Type|Evaluation|
|-|-|-|
|0 == 0U|unsigned|1|
|-1 < 0|signed|1|
|-1 < 0U|unsigned|0|

ìœ„ì™€ ê°™ì´ signedì™€ unsignedê°€ ì„ì—¬ ìˆëŠ” ì—°ì‚°ì€ Implicit í•˜ê²Œ unsignedë¡œ ë°”ë€Œë¯€ë¡œ ì¡°ì‹¬í•´ì•¼ í•œë‹¤.

