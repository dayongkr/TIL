# 문제해결 12주 차

## Dynamic Programming 1

복잡한 문제를 간단한 subproblem으로 나누어 푸는 방법으로 기존에 recursive도 이에 해당한다. 하지만 보통 DP라고 하면 배열로 푸는 것을 의미한다. 또한 Bottom-up 방식으로 푼다. 이에 따라 중복되는 연산을 피할 수 있다.

나눠 푼다고해서 분할 정복을 생각할 수 있지만 그렇지 않고 기존의 더 작은 문제부터 순차적으로 푼다는 점에서 다르다.

### DP 문제를 풀기 위한 단계

1. DP 문제인지 확인한다.
2. subproblem을 정의한다.
3. base case를 정의한다.
4. answer case를 정의한다.
5. 점화식을 정의한다.
6. 구현한다.

DP 문제인지 확인하는 방법은 다음과 같다.

- 문자열, 배열, 순열, 집합 등의 경우
  - Nodes, links, trees, graphs는 보통 아니다
- 최소, 최대, 최적의 값을 구하는 경우
- N^2, N^3의 시간 복잡도를 가지는 경우
  - 각 5000개, 500개 이하의 입력을 가지는 경우이다.
- 최적화의 중간에 중간 상태를 정의할 수 있다.
- 더 큰 경우의 참조 없이 순차적으로 푸는 경우

### Example

#### Ways of Expressing a Number

1,3,5의 합으로 표현할 수 있는 방법의 수를 구하는 문제이다.

- subproblem: A[i] = i를 표현할 수 있는 방법의 수
- base case: A[0] = 1
- answer case: A[n]

위를 토대로 A[i] = A[i-1] + A[i-3] + A[i-5]와 같은 점화식을 구할 수 있다. A[i-1], A[i-3], A[i-5]는 이미 과거에 구해놓은 값이다. DP는 현재와 과거에 대해 집중하는 것이다.

#### Longest Increasing Subsequence

주어진 배열에서 가장 긴 증가하는 부분 수열을 구하는 문제이다.

- subproblem: A[i] = i번째 원소를 마지막으로 하는 LIS의 길이
- base case: A[0] = 1
- answer case: max(A[i])
  - A[i]가 가장 긴 증가하는 부분 수열의 길이가 아닐 수도 있다.

#### Collecting Numbers

1,1 에서 N,N으로 이동하면서 각 cell에 있는 숫자를 더 해서 가장 큰 값을 구하는 문제이다. 이동은 오른쪽, 아래쪽으로만 가능하다.

- subproblem: A[i][j] = (1,1)에서 (i,j)까지 이동하면서 얻을 수 있는 최대값
- base case
  - A[1][1] = nums[1][1]
  - A[1][i] = A[1][i-1] + nums[1][i]
  - A[i][1] = A[i-1][1] + nums[i][1]
- answer case: A[n][n]

다음을 이동할 때 해당 블럭의 위와 왼쪽의 블럭의 최대값을 더해주면 된다. 즉 점화식으로 나타내면 A[i][j] = max(A[i-1][j], A[i][j-1]) + nums[i][j]이다.

어떠한 주소를 선택했는지 알면 이동한 경로를 알 수 있다.

#### Building 27

N개의 계단을 가진 Building 27에서 한 번에 M개의 계단을 오를 수 있는데 한 번에 K번의 계단은 오를 수 없다. 이때 N번째 계단에 도착할 수 있는 경우의 수를 구하는 문제이다.

- subproblem: A[i] = i번째 계단에 도착할 수 있는 경우의 수
- base case
  - A[0] = 1
  - A[1] = 1
- answer case: A[n]

A[i] = A[i-1] + A[i-2] + ... + A[i-m]이다. 여기서 추가로 K번의 계단을 오를 수 없다는 조건을 추가해야 한다.

이렇게하면 O(NM)의 시간 복잡도를 가진다. 하지만 이를 O(N)으로 줄일 수 있다. 기존에 배웠던 sliding window를 이용하면 되는데 추가되는 값과 빠지는 값을 더하고 빼는 것이다.
