# 문제해결 13주 차

이번 주 또한 DP에 대해서 다뤘는데 좀 더 어려운 예제를 가지고 설명하는 식으로 진행되었다.

## 예제 문제

### LCS (Longest Common Subsequence)

> [문제 링크](https://www.acmicpc.net/problem/9251) 교안에서는 Leetcode를 사용했는데 결국 같은 문제이다.

이 문제는 두 문자열이 주어졌을 때, 두 문자열의 가장 긴 공통 부분 수열을 찾는 문제이다. longest, sequence에서 DP를 떠올리는 것이 자연스럽다.

이제 subproblem을 정의해야 하는데 한 문자열이 i번째 문자까지, 다른 문자열이 j번째 문자까지 있을 때, 두 문자열의 가장 긴 공통 부분 수열의 길이를 `dp[i][j]`라고 하면 풀기 쉬워진다. 이렇게하면 base case는 `dp[0][j]`와 `dp[i][0]` 는 모두 0이 된다. 이제 점화식을 세우면 다음과 같다.

1. `s1[i] == s2[j]`인 경우: `dp[i][j] = dp[i-1][j-1] + 1`
2. `s1[i] != s2[j]`인 경우: `dp[i][j] = max(dp[i-1][j], dp[i][j-1])`

보통 DP에서는 0-based 보단 1-based를 사용하는데 이는 dp에서는 i-1과 같이 음수가 발생할 수 있기 때문이다. 그래서 구현의 편의상 1-based로 구현하는 것이 좋다.

### Edit Distance (최소 편집)

> [문제 링크](https://www.acmicpc.net/problem/15483)

이 문제는 두 문자열이 주어졌을 때, 두 문자열이 같아지기 위해 최소 몇 번의 편집이 필요한지 구하는 문제이다. 즉 얼마나 비슷한지에 대한 문제이다. 이 또한 String, minimum에서 DP를 떠올릴 수 있다.

이 문제도 LCS와 유사한데 똑같이 i, j 2차원 DP 배열을 사용하여 i, j 일때의 최소 편집 횟수를 저장한다. 이 때 base case는 각 반대 문자열이 비어 있으면 문자열의 갯수 만큼 삭제해야 하므로 `dp[0][j] = j`, `dp[i][0] = i`가 된다. 점화식은 다음과 같다.

1. `s1[i] == s2[j]`인 경우: `dp[i][j] = dp[i-1][j-1]`
   1. 아무것도 안해도 된다.
2. `s1[i] != s2[j]`인 경우: `dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1`
   1. `dp[i-1][j]`: s1에서 문자를 삭제한다. || s2에 문자를 삽입한다.
   2. `dp[i][j-1]`: s2에서 문자를 삭제한다. || s1에 문자를 삽입한다.
   3. `dp[i-1][j-1]`: 두 문자를 교체한다.
   4. 이 중 가장 작은 값에 1을 더한다.

### Burst Balloons

> [문제 링크](https://leetcode.com/problems/burst-balloons/)

이 문제는 풍선이 주어졌을 때, 풍선을 터뜨리는 순서에 따라서 얻을 수 있는 최대 점수를 구하는 문제이다. 이때 점수의 계산은 터뜨린 풍선의 왼쪽과 오른쪽의 숫자를 곱한 값이다. 만약에 왼쪽이나 오른쪽이 없다면 이는 1로 대체한다.

이 문제도 array, max에 대한 문제이기 때문에 DP를 떠올리면 좋다. 또한 중간에서 터졌을 경우를 체크하기 위해 배열은 하나지만 2차원 배열을 사용한다. 이 때 subproblem은 `dp[i][j]`로 정의하고 i번째부터 j번째까지 터뜨렸을 때 얻을 수 있는 최대 점수를 저장한다. 따라서 answer case는 `dp[0][n-1]`이 된다.

위에 간단히 설명한 것처럼 같은 i~j여도 어디를 마지막으로 터뜨렸는지에 따라서 점수가 달라지기 때문에 모든 경우를 다 해보는 것이 좋다. 따라서 추가로 k를 두어 i~j까지 순회하며 가장 큰 값을 찾는다. 이 때 점화식은 다음과 같다.

1. `dp[i][j] = max(dp[i][j], dp[i][k-1] + dp[k+1][j] + nums[i-1] * nums[k] * nums[j+1])`
   1. `dp[i][k-1]`: i~k-1까지 터뜨렸을 때 얻을 수 있는 최대 점수
   2. `dp[k+1][j]`: k+1~j까지 터뜨렸을 때 얻을 수 있는 최대 점수
   3. `nums[i-1] * nums[k] * nums[j+1]`: i~j까지 터뜨렸을 때 얻을 수 있는 점수

이렇게 끝나면 안되고 각 경계값 또한 신경 써줘야 한다.

```c
#define max(a, b) ((a) > (b) ? (a) : (b))
int a[501][501];

int maxCoins(int *nums, int n){

for (int i = 0; i < n; i++)
   for (int j = 0; j< n; j++)
      a[i][j]= 0;

for (int i = n - 1; i >= 0; i--) // anser case가 i=0 이므로 i를 뒤에서부터 채워나간다.
   for (int j=i; j< n; j++)
      for (int k = i; k <= j; k++)
      {
         int left = k == i ? 0 : a[i][k - 1]; // k == i인 경우 왼쪽이 없다.
         int right = k == j ? 0 : a[k + 1][j]; // k == j인 경우 오른쪽이 없다.
         // i == 0이거나 j == n - 1인 경우 왼쪽이나 오른쪽이 없다.
         int curr = (i == 0 ? 1 : nums[i - 1]) * nums [k] * (j == n - 1 ? 1 : nums[j + 1]);

         a[i][j] = max(a[i][j], left + curr + right);
      }
return a[0][n - 1];
}
```
